
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{hw4}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{Computer Vision}\label{computer-vision}

\section{Jacobs University Bremen}\label{jacobs-university-bremen}

\section{Fall 2020}\label{fall-2020}

\section{Homework 4}\label{homework-4}

This assignment covers the Harris corner detector, RANSAC and the HOG
descriptor for panorama stitching.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} Setup}
        \PY{k+kn}{from} \PY{n+nn}{\PYZus{}\PYZus{}future\PYZus{}\PYZus{}} \PY{k}{import} \PY{n}{print\PYZus{}function}
        \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
        \PY{k+kn}{from} \PY{n+nn}{skimage} \PY{k}{import} \PY{n}{filters}
        \PY{k+kn}{from} \PY{n+nn}{skimage}\PY{n+nn}{.}\PY{n+nn}{feature} \PY{k}{import} \PY{n}{corner\PYZus{}peaks}
        \PY{k+kn}{from} \PY{n+nn}{skimage}\PY{n+nn}{.}\PY{n+nn}{io} \PY{k}{import} \PY{n}{imread}
        \PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
        \PY{k+kn}{from} \PY{n+nn}{time} \PY{k}{import} \PY{n}{time}
        
        \PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
        \PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{figure.figsize}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{15.0}\PY{p}{,} \PY{l+m+mf}{12.0}\PY{p}{)} \PY{c+c1}{\PYZsh{} set default size of plots}
        \PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{image.interpolation}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{nearest}\PY{l+s+s1}{\PYZsq{}}
        \PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{image.cmap}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gray}\PY{l+s+s1}{\PYZsq{}}
        
        \PY{c+c1}{\PYZsh{} for auto\PYZhy{}reloading extenrnal modules}
        \PY{o}{\PYZpc{}}\PY{k}{load\PYZus{}ext} autoreload
        \PY{o}{\PYZpc{}}\PY{k}{autoreload} 2
\end{Verbatim}


    \subsection{Introduction: Panorama
Stitching}\label{introduction-panorama-stitching}

Panorama stitching is an early success of computer vision. Matthew Brown
and David G. Lowe published a famous
\href{http://matthewalunbrown.com/papers/ijcv2007.pdf}{panoramic image
stitching paper} in 2007. Since then, automatic panorama stitching
technology has been widely adopted in many applications such as Google
Street View, panorama photos on smartphones, and stitching software such
as Photosynth and AutoStitch.

In this assignment, we will detect and match keypoints from multiple
images to build a single panoramic image. This will involve several
tasks: 1. Use Harris corner detector to find keypoints. 2. Build a
descriptor to describe each point in an image. Compare two sets of
descriptors coming from two different images and find matching
keypoints. 3. Given a list of matching keypoints, use least-squares
method to find the affine transformation matrix that maps points in one
image to another. 4. Use RANSAC to give a more robust estimate of affine
transformation matrix. Given the transformation matrix, use it to
transform the second image and overlay it on the first image, forming a
panorama. 5. Implement a different descriptor (HOG descriptor) and get
another stitching result.

    \subsection{Part 1 Harris Corner Detector (20
points)}\label{part-1-harris-corner-detector-20-points}

In this section, you are going to implement Harris corner detector for
keypoint localization. Review the lecture slides on Harris corner
detector to understand how it works. The Harris detection algorithm can
be divide into the following steps: 1. Compute \(x\) and \(y\)
derivatives (\(I_x, I_y\)) of an image 2. Compute products of
derivatives (\(I_x^2, I_y^2, I_{xy}\)) at each pixel 3. Compute matrix
\(M\) at each pixel, where \[
M = \sum_{x,y} w(x,y)
    \begin{bmatrix}
        I_{x}^2 & I_{x}I_{y} \\
        I_{x}I_{y} & I_{y}^2
    \end{bmatrix}
\] 4. Compute corner response \(R=Det(M)-k(Trace(M)^2)\) at each pixel
5. Output corner response map \(R(x,y)\)

Step 1 is already done for you in the function
\textbf{\texttt{harris\_corners}} in \texttt{panorama.py}. Complete the
function implementation and run the code below.

\emph{-Hint: You may use the function
\texttt{scipy.ndimage.filters.convolve}, which is already imported in
\texttt{panoramy.py}}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{harris\PYZus{}corners}
        
        \PY{n}{img} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sudoku.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Compute Harris corner response}
        \PY{n}{response} \PY{o}{=} \PY{n}{harris\PYZus{}corners}\PY{p}{(}\PY{n}{img}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Display corner response}
        \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{response}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Harris Corner Response}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{solution\PYZus{}harris.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Harris Corner Solution}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_4_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Once you implement the Harris detector correctly, you will be able to
see small bright blobs around the corners of the sudoku grids and
letters in the output corner response image. The function
\texttt{corner\_peaks} from \texttt{skimage.feature} performs
non-maximum suppression to take local maxima of the response map and
localize keypoints.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} Perform non\PYZhy{}maximum suppression in response map}
        \PY{c+c1}{\PYZsh{} and output corner coordiantes}
        \PY{n}{corners} \PY{o}{=} \PY{n}{corner\PYZus{}peaks}\PY{p}{(}\PY{n}{response}\PY{p}{,} \PY{n}{threshold\PYZus{}rel}\PY{o}{=}\PY{l+m+mf}{0.01}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Display detected corners}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{n}{corners}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{corners}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Detected Corners}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_6_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Part 2 Describing and Matching Keypoints (20
points)}\label{part-2-describing-and-matching-keypoints-20-points}

We are now able to localize keypoints in two images by running the
Harris corner detector independently on them. Next question is, how do
we determine which pair of keypoints come from corresponding locations
in those two images? In order to \emph{match} the detected keypoints, we
must come up with a way to \emph{describe} the keypoints based on their
local appearance. Generally, each region around detected keypoint
locations is converted into a fixed-size vectors called
\emph{descriptors}.

\subsubsection{Part 2.1 Creating Descriptors (10
points)}\label{part-2.1-creating-descriptors-10-points}

In this section, you are going to implement the
\textbf{\texttt{simple\_descriptor}} function, where each keypoint is
described by the normalized intensity of a small patch around it.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{harris\PYZus{}corners}
        
        \PY{n}{img1} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{uttower1.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{n}{img2} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{uttower2.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Detect keypoints in two images}
        \PY{n}{keypoints1} \PY{o}{=} \PY{n}{corner\PYZus{}peaks}\PY{p}{(}\PY{n}{harris\PYZus{}corners}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{window\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,}
                                  \PY{n}{threshold\PYZus{}rel}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,}
                                  \PY{n}{exclude\PYZus{}border}\PY{o}{=}\PY{l+m+mi}{8}\PY{p}{)}
        \PY{n}{keypoints2} \PY{o}{=} \PY{n}{corner\PYZus{}peaks}\PY{p}{(}\PY{n}{harris\PYZus{}corners}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{window\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,}
                                  \PY{n}{threshold\PYZus{}rel}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,}
                                  \PY{n}{exclude\PYZus{}border}\PY{o}{=}\PY{l+m+mi}{8}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Display detected keypoints}
        \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img1}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{n}{keypoints1}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{keypoints1}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Detected Keypoints for Image 1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img2}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{n}{keypoints2}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Detected Keypoints for Image 2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_8_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsubsection{Part 2.2 Matching Descriptors (10
points)}\label{part-2.2-matching-descriptors-10-points}

Next, implement the \textbf{\texttt{match\_descriptors}} function to
find good matches in two sets of descriptors. First, calculate Euclidean
distance between all pairs of descriptors from image 1 and image 2. Then
use this to determine if there is a good match: if the distance to the
closest vector is significantly (by a given factor) smaller than the
distance to the second-closest, we call it a match. The output of the
function is an array where each row holds the indices of one pair of
matching descriptors.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{simple\PYZus{}descriptor}\PY{p}{,} \PY{n}{match\PYZus{}descriptors}\PY{p}{,} \PY{n}{describe\PYZus{}keypoints}
        \PY{k+kn}{from} \PY{n+nn}{utils} \PY{k}{import} \PY{n}{plot\PYZus{}matches}
        
        \PY{n}{patch\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{5}
            
        \PY{c+c1}{\PYZsh{} Extract features from the corners}
        \PY{n}{desc1} \PY{o}{=} \PY{n}{describe\PYZus{}keypoints}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{keypoints1}\PY{p}{,}
                                   \PY{n}{desc\PYZus{}func}\PY{o}{=}\PY{n}{simple\PYZus{}descriptor}\PY{p}{,}
                                   \PY{n}{patch\PYZus{}size}\PY{o}{=}\PY{n}{patch\PYZus{}size}\PY{p}{)}
        \PY{n}{desc2} \PY{o}{=} \PY{n}{describe\PYZus{}keypoints}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,}
                                   \PY{n}{desc\PYZus{}func}\PY{o}{=}\PY{n}{simple\PYZus{}descriptor}\PY{p}{,}
                                   \PY{n}{patch\PYZus{}size}\PY{o}{=}\PY{n}{patch\PYZus{}size}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Match descriptors in image1 to those in image2}
        \PY{n}{matches} \PY{o}{=} \PY{n}{match\PYZus{}descriptors}\PY{p}{(}\PY{n}{desc1}\PY{p}{,} \PY{n}{desc2}\PY{p}{,} \PY{l+m+mf}{0.7}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Plot matches}
        \PY{n}{fig}\PY{p}{,} \PY{n}{ax} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{15}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plot\PYZus{}matches}\PY{p}{(}\PY{n}{ax}\PY{p}{,} \PY{n}{img1}\PY{p}{,} \PY{n}{img2}\PY{p}{,} \PY{n}{keypoints1}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,} \PY{n}{matches}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{solution\PYZus{}simple\PYZus{}descriptor.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Matched Simple Descriptor Solution}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_10_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_10_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Part 3 Transformation Estimation (20
points)}\label{part-3-transformation-estimation-20-points}

We now have a list of matched keypoints across the two images. We will
use this to find a transformation matrix that maps points in the second
image to the corresponding coordinates in the first image. In other
words, if the point \(p_1 = [y_1,x_1]\) in image 1 matches with
\(p_2=[y_2, x_2]\) in image 2, we need to find an affine transformation
matrix \(H\) such that

\[
\tilde{p_2}H = \tilde{p_1},
\]

where \(\tilde{p_1}\) and \(\tilde{p_2}\) are homogenous coordinates of
\(p_1\) and \(p_2\).

Note that it may be impossible to find the transformation \(H\) that
maps every point in image 2 exactly to the corresponding point in image
1. However, we can estimate the transformation matrix with least
squares. Given \(N\) matched keypoint pairs, let \(X_1\) and \(X_2\) be
\(N \times 3\) matrices whose rows are homogenous coordinates of
corresponding keypoints in image 1 and image 2 respectively. Then, we
can estimate \(H\) by solving the least squares problem,

\[
X_2 H = X_1
\]

Implement \textbf{\texttt{fit\_affine\_matrix}} in \texttt{panorama.py}

\emph{-Hint: read the
\href{https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html}{documentation}
about np.linalg.lstsq}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{fit\PYZus{}affine\PYZus{}matrix}
        
        \PY{c+c1}{\PYZsh{} Sanity check for fit\PYZus{}affine\PYZus{}matrix}
        
        \PY{c+c1}{\PYZsh{} Test inputs}
        \PY{n}{a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mf}{0.5}\PY{p}{,} \PY{l+m+mf}{0.1}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mf}{0.4}\PY{p}{,} \PY{l+m+mf}{0.2}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mf}{0.8}\PY{p}{,} \PY{l+m+mf}{0.2}\PY{p}{]}\PY{p}{]}\PY{p}{)}
        \PY{n}{b} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mf}{0.3}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{0.2}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mf}{0.4}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{0.9}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mf}{0.1}\PY{p}{,} \PY{l+m+mf}{0.1}\PY{p}{]}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{H} \PY{o}{=} \PY{n}{fit\PYZus{}affine\PYZus{}matrix}\PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{a}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Target output}
        \PY{n}{sol} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}
            \PY{p}{[}\PY{p}{[}\PY{l+m+mf}{1.25}\PY{p}{,} \PY{l+m+mf}{2.5}\PY{p}{,} \PY{l+m+mf}{0.0}\PY{p}{]}\PY{p}{,}
             \PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mf}{5.75}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{4.5}\PY{p}{,} \PY{l+m+mf}{0.0}\PY{p}{]}\PY{p}{,}
             \PY{p}{[}\PY{l+m+mf}{0.25}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{1.0}\PY{p}{,} \PY{l+m+mf}{1.0}\PY{p}{]}\PY{p}{]}
        \PY{p}{)}
        
        \PY{n}{error} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{(}\PY{n}{H} \PY{o}{\PYZhy{}} \PY{n}{sol}\PY{p}{)} \PY{o}{*}\PY{o}{*} \PY{l+m+mi}{2}\PY{p}{)}
        
        \PY{k}{if} \PY{n}{error} \PY{o}{\PYZlt{}} \PY{l+m+mf}{1e\PYZhy{}20}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Implementation correct!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{There is something wrong.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Implementation correct!

    \end{Verbatim}

    After checking that your \texttt{fit\_affine\_matrix} function is
running correctly, run the following code to apply it to images. Images
will be warped and image 2 will be mapped to image 1.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{k+kn}{from} \PY{n+nn}{utils} \PY{k}{import} \PY{n}{get\PYZus{}output\PYZus{}space}\PY{p}{,} \PY{n}{warp\PYZus{}image}
        
        \PY{c+c1}{\PYZsh{} Extract matched keypoints}
        \PY{n}{p1} \PY{o}{=} \PY{n}{keypoints1}\PY{p}{[}\PY{n}{matches}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{]}
        \PY{n}{p2} \PY{o}{=} \PY{n}{keypoints2}\PY{p}{[}\PY{n}{matches}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}
        
        \PY{c+c1}{\PYZsh{} Find affine transformation matrix H that maps p2 to p1}
        \PY{n}{H} \PY{o}{=} \PY{n}{fit\PYZus{}affine\PYZus{}matrix}\PY{p}{(}\PY{n}{p1}\PY{p}{,} \PY{n}{p2}\PY{p}{)}
        
        \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset} \PY{o}{=} \PY{n}{get\PYZus{}output\PYZus{}space}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{p}{[}\PY{n}{img2}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{n}{H}\PY{p}{]}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Output shape:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Offset:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
        
        
        \PY{c+c1}{\PYZsh{} Warp images into output sapce}
        \PY{n}{img1\PYZus{}warped} \PY{o}{=} \PY{n}{warp\PYZus{}image}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{eye}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
        \PY{n}{img1\PYZus{}mask} \PY{o}{=} \PY{p}{(}\PY{n}{img1\PYZus{}warped} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} Mask == 1 inside the image}
        \PY{n}{img1\PYZus{}warped}\PY{p}{[}\PY{o}{\PYZti{}}\PY{n}{img1\PYZus{}mask}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}     \PY{c+c1}{\PYZsh{} Return background values to 0}
        
        \PY{n}{img2\PYZus{}warped} \PY{o}{=} \PY{n}{warp\PYZus{}image}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{H}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
        \PY{n}{img2\PYZus{}mask} \PY{o}{=} \PY{p}{(}\PY{n}{img2\PYZus{}warped} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} Mask == 1 inside the image}
        \PY{n}{img2\PYZus{}warped}\PY{p}{[}\PY{o}{\PYZti{}}\PY{n}{img2\PYZus{}mask}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}     \PY{c+c1}{\PYZsh{} Return background values to 0}
        
        \PY{c+c1}{\PYZsh{} Plot warped images}
        \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img1\PYZus{}warped}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image 1 warped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img2\PYZus{}warped}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image 2 warped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Output shape: [496 615]
Offset: [-39.37184617   0.        ]

    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_14_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Next, the two warped images are merged to get a panorama. Your panorama
may not look good at this point, but we will later use other techniques
to get a better result.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n}{merged} \PY{o}{=} \PY{n}{img1\PYZus{}warped} \PY{o}{+} \PY{n}{img2\PYZus{}warped}
        
        \PY{c+c1}{\PYZsh{} Track the overlap by adding the masks together}
        \PY{n}{overlap} \PY{o}{=} \PY{p}{(}\PY{n}{img1\PYZus{}mask} \PY{o}{*} \PY{l+m+mf}{1.0} \PY{o}{+}  \PY{c+c1}{\PYZsh{} Multiply by 1.0 for bool \PYZhy{}\PYZgt{} float conversion}
                   \PY{n}{img2\PYZus{}mask}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Normalize through division by `overlap` \PYZhy{} but ensure the minimum is 1}
        \PY{n}{normalized} \PY{o}{=} \PY{n}{merged} \PY{o}{/} \PY{n}{np}\PY{o}{.}\PY{n}{maximum}\PY{p}{(}\PY{n}{overlap}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{normalized}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_16_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Part 4 RANSAC (20 points)}\label{part-4-ransac-20-points}

Rather than directly feeding all our keypoint matches into
\texttt{fit\_affine\_matrix} function, we can instead use RANSAC
("RANdom SAmple Consensus") to select only "inliers" to use for
computing the transformation matrix.

The steps of RANSAC are: 1. Select random set of matches 2. Compute
affine transformation matrix 3. Find inliers using the given threshold
4. Repeat and keep the largest set of inliers 5. Re-compute
least-squares estimate on all of the inliers

Implement \textbf{\texttt{ransac}} in \texttt{panorama.py}, run through
the following code to get a panorama. You can see the difference from
the result we get without RANSAC.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{ransac}
         
         \PY{c+c1}{\PYZsh{} Set seed to compare output against solution image}
         \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{l+m+mi}{131}\PY{p}{)}
         
         \PY{n}{H}\PY{p}{,} \PY{n}{robust\PYZus{}matches} \PY{o}{=} \PY{n}{ransac}\PY{p}{(}\PY{n}{keypoints1}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,} \PY{n}{matches}\PY{p}{,} \PY{n}{threshold}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Visualize robust matches}
         \PY{n}{fig}\PY{p}{,} \PY{n}{ax} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{15}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{)}\PY{p}{)}
         \PY{n}{plot\PYZus{}matches}\PY{p}{(}\PY{n}{ax}\PY{p}{,} \PY{n}{img1}\PY{p}{,} \PY{n}{img2}\PY{p}{,} \PY{n}{keypoints1}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,} \PY{n}{robust\PYZus{}matches}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{solution\PYZus{}ransac.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RANSAC Solution}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
41
[[ 1.01384971e+00  3.86900855e-02  0.00000000e+00]
 [-2.74365144e-02  1.02897308e+00  0.00000000e+00]
 [ 2.12108134e+01  2.55769724e+02  1.00000000e+00]]

    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_18_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_18_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    We can now use the tranformation matrix \(H\) computed using the robust
matches to warp our images and create a better-looking panorama.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset} \PY{o}{=} \PY{n}{get\PYZus{}output\PYZus{}space}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{p}{[}\PY{n}{img2}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{n}{H}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Warp images into output sapce}
         \PY{n}{img1\PYZus{}warped} \PY{o}{=} \PY{n}{warp\PYZus{}image}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{eye}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
         \PY{n}{img1\PYZus{}mask} \PY{o}{=} \PY{p}{(}\PY{n}{img1\PYZus{}warped} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} Mask == 1 inside the image}
         \PY{n}{img1\PYZus{}warped}\PY{p}{[}\PY{o}{\PYZti{}}\PY{n}{img1\PYZus{}mask}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}     \PY{c+c1}{\PYZsh{} Return background values to 0}
         
         \PY{n}{img2\PYZus{}warped} \PY{o}{=} \PY{n}{warp\PYZus{}image}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{H}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
         \PY{n}{img2\PYZus{}mask} \PY{o}{=} \PY{p}{(}\PY{n}{img2\PYZus{}warped} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} Mask == 1 inside the image}
         \PY{n}{img2\PYZus{}warped}\PY{p}{[}\PY{o}{\PYZti{}}\PY{n}{img2\PYZus{}mask}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}     \PY{c+c1}{\PYZsh{} Return background values to 0}
         
         \PY{c+c1}{\PYZsh{} Plot warped images}
         \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img1\PYZus{}warped}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image 1 warped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img2\PYZus{}warped}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image 2 warped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_20_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n}{merged} \PY{o}{=} \PY{n}{img1\PYZus{}warped} \PY{o}{+} \PY{n}{img2\PYZus{}warped}
         
         \PY{c+c1}{\PYZsh{} Track the overlap by adding the masks together}
         \PY{n}{overlap} \PY{o}{=} \PY{p}{(}\PY{n}{img1\PYZus{}mask} \PY{o}{*} \PY{l+m+mf}{1.0} \PY{o}{+}  \PY{c+c1}{\PYZsh{} Multiply by 1.0 for bool \PYZhy{}\PYZgt{} float conversion}
                    \PY{n}{img2\PYZus{}mask}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Normalize through division by `overlap` \PYZhy{} but ensure the minimum is 1}
         \PY{n}{normalized} \PY{o}{=} \PY{n}{merged} \PY{o}{/} \PY{n}{np}\PY{o}{.}\PY{n}{maximum}\PY{p}{(}\PY{n}{overlap}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{normalized}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{solution\PYZus{}ransac\PYZus{}panorama.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RANSAC Panorama Solution}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_21_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_21_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Part 5 Histogram of Oriented Gradients (HOG) (20
points)}\label{part-5-histogram-of-oriented-gradients-hog-20-points}

In the above code, you are using the \texttt{simple\_descriptor}, and in
this section, you are going to implement a simplified version of HOG
descriptor. HOG stands for Histogram of Oriented Gradients. In HOG
descriptor, the distribution ( histograms ) of the directions of
gradients ( oriented gradients ) are used as features. Gradients ( x and
y derivatives ) of an image are useful because the magnitude of a
gradient is large around edges and corners ( regions of abrupt intensity
changes ) and we know that edges and corners pack in a lot more
information about object shape than flat regions. The steps of HOG are:
1. Compute the gradient image in x and y directions Use the sobel filter
provided by skimage.filters 2. Compute gradient histograms Divide image
into cells, and calculate histogram of gradients in each cell 3. Flatten
block of histograms into feature vector 4. Normalize flattened block

Implement \textbf{\texttt{hog\_descriptor}} in \texttt{panorama.py} and
run through the following code to get a panorama image.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{hog\PYZus{}descriptor}
         
         \PY{n}{img1} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{uttower1.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n}{img2} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{uttower2.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Detect keypoints in both images}
         \PY{n}{keypoints1} \PY{o}{=} \PY{n}{corner\PYZus{}peaks}\PY{p}{(}\PY{n}{harris\PYZus{}corners}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{window\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,}
                                   \PY{n}{threshold\PYZus{}rel}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,}
                                   \PY{n}{exclude\PYZus{}border}\PY{o}{=}\PY{l+m+mi}{8}\PY{p}{)}
         \PY{n}{keypoints2} \PY{o}{=} \PY{n}{corner\PYZus{}peaks}\PY{p}{(}\PY{n}{harris\PYZus{}corners}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{window\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,}
                                   \PY{n}{threshold\PYZus{}rel}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,}
                                   \PY{n}{exclude\PYZus{}border}\PY{o}{=}\PY{l+m+mi}{8}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{c+c1}{\PYZsh{} Extract features from the corners}
         \PY{n}{desc1} \PY{o}{=} \PY{n}{describe\PYZus{}keypoints}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{keypoints1}\PY{p}{,}
                                    \PY{n}{desc\PYZus{}func}\PY{o}{=}\PY{n}{hog\PYZus{}descriptor}\PY{p}{,}
                                    \PY{n}{patch\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{16}\PY{p}{)}
         \PY{n}{desc2} \PY{o}{=} \PY{n}{describe\PYZus{}keypoints}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,}
                                    \PY{n}{desc\PYZus{}func}\PY{o}{=}\PY{n}{hog\PYZus{}descriptor}\PY{p}{,}
                                    \PY{n}{patch\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{16}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Match descriptors in image1 to those in image2}
         \PY{n}{matches} \PY{o}{=} \PY{n}{match\PYZus{}descriptors}\PY{p}{(}\PY{n}{desc1}\PY{p}{,} \PY{n}{desc2}\PY{p}{,} \PY{l+m+mf}{0.7}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot matches}
         \PY{n}{fig}\PY{p}{,} \PY{n}{ax} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{15}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plot\PYZus{}matches}\PY{p}{(}\PY{n}{ax}\PY{p}{,} \PY{n}{img1}\PY{p}{,} \PY{n}{img2}\PY{p}{,} \PY{n}{keypoints1}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,} \PY{n}{matches}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{solution\PYZus{}hog.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{HOG descriptor Solution}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_24_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_24_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Once we've described our keypoints with the HOG descriptor and have
found matches between these keypoints, we can use RANSAC to select
robust matches for computing the tranasformtion matrix.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{ransac}
         
         \PY{c+c1}{\PYZsh{} Set seed to compare output against solution image}
         \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{l+m+mi}{131}\PY{p}{)}
         
         \PY{n}{H}\PY{p}{,} \PY{n}{robust\PYZus{}matches} \PY{o}{=} \PY{n}{ransac}\PY{p}{(}\PY{n}{keypoints1}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,} \PY{n}{matches}\PY{p}{,} \PY{n}{threshold}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot matches}
         \PY{n}{fig}\PY{p}{,} \PY{n}{ax} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{15}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{)}\PY{p}{)}
         \PY{n}{plot\PYZus{}matches}\PY{p}{(}\PY{n}{ax}\PY{p}{,} \PY{n}{img1}\PY{p}{,} \PY{n}{img2}\PY{p}{,} \PY{n}{keypoints1}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,} \PY{n}{robust\PYZus{}matches}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{solution\PYZus{}hog\PYZus{}ransac.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{HOG descriptor + RANSAC Solution}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
39
[[ 1.03526902e+00  4.56842835e-02  0.00000000e+00]
 [-3.60814327e-02  1.02966706e+00  0.00000000e+00]
 [ 1.66792127e+01  2.53376046e+02  1.00000000e+00]]

    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_26_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_26_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Now we use the computed transformation matrix \(H\) to warp our images
and produce our panorama.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset} \PY{o}{=} \PY{n}{get\PYZus{}output\PYZus{}space}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{p}{[}\PY{n}{img2}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{n}{H}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Warp images into output sapce}
         \PY{n}{img1\PYZus{}warped} \PY{o}{=} \PY{n}{warp\PYZus{}image}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{eye}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
         \PY{n}{img1\PYZus{}mask} \PY{o}{=} \PY{p}{(}\PY{n}{img1\PYZus{}warped} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} Mask == 1 inside the image}
         \PY{n}{img1\PYZus{}warped}\PY{p}{[}\PY{o}{\PYZti{}}\PY{n}{img1\PYZus{}mask}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}     \PY{c+c1}{\PYZsh{} Return background values to 0}
         
         \PY{n}{img2\PYZus{}warped} \PY{o}{=} \PY{n}{warp\PYZus{}image}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{H}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
         \PY{n}{img2\PYZus{}mask} \PY{o}{=} \PY{p}{(}\PY{n}{img2\PYZus{}warped} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} Mask == 1 inside the image}
         \PY{n}{img2\PYZus{}warped}\PY{p}{[}\PY{o}{\PYZti{}}\PY{n}{img2\PYZus{}mask}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}     \PY{c+c1}{\PYZsh{} Return background values to 0}
         
         \PY{c+c1}{\PYZsh{} Plot warped images}
         \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img1\PYZus{}warped}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image 1 warped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{img2\PYZus{}warped}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image 2 warped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_28_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n}{merged} \PY{o}{=} \PY{n}{img1\PYZus{}warped} \PY{o}{+} \PY{n}{img2\PYZus{}warped}
         
         \PY{c+c1}{\PYZsh{} Track the overlap by adding the masks together}
         \PY{n}{overlap} \PY{o}{=} \PY{p}{(}\PY{n}{img1\PYZus{}mask} \PY{o}{*} \PY{l+m+mf}{1.0} \PY{o}{+}  \PY{c+c1}{\PYZsh{} Multiply by 1.0 for bool \PYZhy{}\PYZgt{} float conversion}
                    \PY{n}{img2\PYZus{}mask}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Normalize through division by `overlap` \PYZhy{} but ensure the minimum is 1}
         \PY{n}{normalized} \PY{o}{=} \PY{n}{merged} \PY{o}{/} \PY{n}{np}\PY{o}{.}\PY{n}{maximum}\PY{p}{(}\PY{n}{overlap}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{normalized}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{solution\PYZus{}hog\PYZus{}panorama.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{HOG Descriptor Panorama Solution}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_29_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_29_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Extra Credit: Better Image
Merging}\label{extra-credit-better-image-merging}

You will notice the blurry region and unpleasant lines in the middle of
the final panoramic image. Using a very simple technique called linear
blending, we can smooth out a lot of these artifacts from the panorama.

Currently, all the pixels in the overlapping region are weighted
equally. However, since the pixels at the left and right ends of the
overlap are very well complemented by the pixels in the other image,
they can be made to contribute less to the final panorama.

Linear blending can be done with the following steps: 1. Define left and
right margins for blending to occur between 2. Define a weight matrix
for image 1 such that: - From the left of the output space to the left
margin the weight is 1 - From the left margin to the right margin, the
weight linearly decrements from 1 to 0 3. Define a weight matrix for
image 2 such that: - From the right of the output space to the right
margin the weight is 1 - From the left margin to the right margin, the
weight linearly increments from 0 to 1 4. Apply the weight matrices to
their corresponding images 5. Combine the images

In \textbf{\texttt{linear\_blend}} in \texttt{panorama.py} implement the
linear blending scheme to make the panorama look more natural. This
extra credit can be worth up to 1\% of your final grade.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{linear\PYZus{}blend}
         
         \PY{n}{img1} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{uttower1.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n}{img2} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{uttower2.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Set seed to compare output against solution}
         \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{l+m+mi}{131}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Detect keypoints in both images}
         \PY{n}{keypoints1} \PY{o}{=} \PY{n}{corner\PYZus{}peaks}\PY{p}{(}\PY{n}{harris\PYZus{}corners}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{window\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,}
                                   \PY{n}{threshold\PYZus{}rel}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,}
                                   \PY{n}{exclude\PYZus{}border}\PY{o}{=}\PY{l+m+mi}{8}\PY{p}{)}
         \PY{n}{keypoints2} \PY{o}{=} \PY{n}{corner\PYZus{}peaks}\PY{p}{(}\PY{n}{harris\PYZus{}corners}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{window\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,}
                                   \PY{n}{threshold\PYZus{}rel}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,}
                                   \PY{n}{exclude\PYZus{}border}\PY{o}{=}\PY{l+m+mi}{8}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Extract features from the corners}
         \PY{n}{desc1} \PY{o}{=} \PY{n}{describe\PYZus{}keypoints}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{keypoints1}\PY{p}{,}
                                    \PY{n}{desc\PYZus{}func}\PY{o}{=}\PY{n}{hog\PYZus{}descriptor}\PY{p}{,}
                                    \PY{n}{patch\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{16}\PY{p}{)}
         \PY{n}{desc2} \PY{o}{=} \PY{n}{describe\PYZus{}keypoints}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,}
                                    \PY{n}{desc\PYZus{}func}\PY{o}{=}\PY{n}{hog\PYZus{}descriptor}\PY{p}{,}
                                    \PY{n}{patch\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{16}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Match descriptors in image1 to those in image2}
         \PY{n}{matches} \PY{o}{=} \PY{n}{match\PYZus{}descriptors}\PY{p}{(}\PY{n}{desc1}\PY{p}{,} \PY{n}{desc2}\PY{p}{,} \PY{l+m+mf}{0.7}\PY{p}{)}
         
         \PY{n}{H}\PY{p}{,} \PY{n}{robust\PYZus{}matches} \PY{o}{=} \PY{n}{ransac}\PY{p}{(}\PY{n}{keypoints1}\PY{p}{,} \PY{n}{keypoints2}\PY{p}{,} \PY{n}{matches}\PY{p}{,} \PY{n}{threshold}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
         
         \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset} \PY{o}{=} \PY{n}{get\PYZus{}output\PYZus{}space}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{p}{[}\PY{n}{img2}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{n}{H}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Warp images into output sapce}
         \PY{n}{img1\PYZus{}warped} \PY{o}{=} \PY{n}{warp\PYZus{}image}\PY{p}{(}\PY{n}{img1}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{eye}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
         \PY{n}{img1\PYZus{}mask} \PY{o}{=} \PY{p}{(}\PY{n}{img1\PYZus{}warped} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} Mask == 1 inside the image}
         \PY{n}{img1\PYZus{}warped}\PY{p}{[}\PY{o}{\PYZti{}}\PY{n}{img1\PYZus{}mask}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}     \PY{c+c1}{\PYZsh{} Return background values to 0}
         
         \PY{n}{img2\PYZus{}warped} \PY{o}{=} \PY{n}{warp\PYZus{}image}\PY{p}{(}\PY{n}{img2}\PY{p}{,} \PY{n}{H}\PY{p}{,} \PY{n}{output\PYZus{}shape}\PY{p}{,} \PY{n}{offset}\PY{p}{)}
         \PY{n}{img2\PYZus{}mask} \PY{o}{=} \PY{p}{(}\PY{n}{img2\PYZus{}warped} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} Mask == 1 inside the image}
         \PY{n}{img2\PYZus{}warped}\PY{p}{[}\PY{o}{\PYZti{}}\PY{n}{img2\PYZus{}mask}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{0}     \PY{c+c1}{\PYZsh{} Return background values to 0}
         
         \PY{c+c1}{\PYZsh{} Merge the warped images using linear blending scheme}
         \PY{n}{merged} \PY{o}{=} \PY{n}{linear\PYZus{}blend}\PY{p}{(}\PY{n}{img1\PYZus{}warped}\PY{p}{,} \PY{n}{img2\PYZus{}warped}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{merged}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
39
[[ 1.03526902e+00  4.56842835e-02  0.00000000e+00]
 [-3.60814327e-02  1.02966706e+00  0.00000000e+00]
 [ 1.66792127e+01  2.53376046e+02  1.00000000e+00]]

    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_31_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Extra Credit: Stitching Multiple
Images}\label{extra-credit-stitching-multiple-images}

Implement \textbf{\texttt{stitch\_multiple\_images}} in
\texttt{panorama.py} to stitch together an ordered chain of images. This
extra credit can be worth up to 1 bonus point of your final grade.

Given a sequence of \(m\) images (\(I_1, I_2,...,I_m\)), take every
neighboring pair of images and compute the transformation matrix which
converts points from the coordinate frame of \(I_{i+1}\) to the frame of
\(I_{i}\). Then, select a reference image \(I_{ref}\), which is in the
middle of the chain. We want our final panorama image to be in the
coordinate frame of \(I_{ref}\).

\emph{-Hint:} - If you are confused, you may want to review the Linear
Algebra slides on how to combine the effects of multiple transformation
matrices. - The inverse of transformation matrix has the reverse effect.
Please use
\href{https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html}{\texttt{numpy.linalg.inv}}
function whenever you want to compute matrix inverse.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{k+kn}{from} \PY{n+nn}{panorama} \PY{k}{import} \PY{n}{stitch\PYZus{}multiple\PYZus{}images}
         
         \PY{c+c1}{\PYZsh{} Set seed to compare output against solution}
         \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{l+m+mi}{131}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Load images to be stitched}
         \PY{n}{img1} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{yosemite1.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n}{img2} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{yosemite2.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n}{img3} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{yosemite3.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n}{img4} \PY{o}{=} \PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{yosemite4.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}gray}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         
         \PY{n}{imgs} \PY{o}{=} \PY{p}{[}\PY{n}{img1}\PY{p}{,} \PY{n}{img2}\PY{p}{,} \PY{n}{img3}\PY{p}{,} \PY{n}{img4}\PY{p}{]}
         
         \PY{c+c1}{\PYZsh{} Stitch images together}
         \PY{n}{panorama} \PY{o}{=} \PY{n}{stitch\PYZus{}multiple\PYZus{}images}\PY{p}{(}\PY{n}{imgs}\PY{p}{,} \PY{n}{desc\PYZus{}func}\PY{o}{=}\PY{n}{simple\PYZus{}descriptor}\PY{p}{,} \PY{n}{patch\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
104
[[ 1.01430052e+00 -8.74126842e-04  0.00000000e+00]
 [-4.49268588e-03  1.00564940e+00  0.00000000e+00]
 [-4.01145618e+00  2.77965959e+02  1.00000000e+00]]
159
[[ 1.00061095e+00  2.76499845e-02  0.00000000e+00]
 [-2.64972660e-02  1.00295942e+00  0.00000000e+00]
 [-5.04737951e+00  3.24437895e+02  1.00000000e+00]]
105
[[ 1.00822994e+00  1.74229919e-02  0.00000000e+00]
 [-1.27464579e-02  1.00875300e+00  0.00000000e+00]
 [-2.70886142e+01  3.89104366e+02  1.00000000e+00]]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{c+c1}{\PYZsh{} Visualize final panorama image}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{panorama}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_34_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
